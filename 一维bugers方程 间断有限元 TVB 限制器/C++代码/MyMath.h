/******************************************
 * Filename: MyMath.h
 * File title:
 * Abstract: include some common math functions
 * 
 * Modification date:	March 21, 2010
 ********************************************/

#ifndef  __MYMATH_H
#define  __MYMATH_H
#pragma once
#include <cassert>
#include <cmath>
#include <vector>

using namespace std;

const double  ME_        =  2.7182818284590452353602874713527;		// 自然对数的底{exp(1)}
const double  Pi         =  3.1415926535897932384626433832795;		// 圆周率{2*arcsin(1)}
const double  MGoldNo_   =  0.61803398874989484820458683436564;	        // 黄金分割常数{( sqrt(5)-1 ) / 2}

// sign
inline int Sign(double a)
{
	if(a>=0) return 1;
	else return -1;
}
//min & max
inline double Min(double a,double b)
{
	return (a < b? a : b);
}
inline double Min(double a,double b,double c)
{
	return (a < Min(b,c)? a : Min(b,c));
}
inline double Max(double a,double b)
{
	return (a > b? a : b);
}
inline double Max(double a,double b,double c)
{
	return (a > Max(b,c)? a : Max(b,c));
}
inline double AbsMax(const vector<double>& v)
{
	//ok!
	double s(0);
	for(unsigned int i = 0; i != v.size(); ++i)
	{
		if(fabs(v[i]) > s)
			s = fabs(v[i]);
	}
	return s;
}
// minmod
inline double Minmod(double a, double b)
{
	double temp = fabs(a);
	if((a<0 && b<0) || (a>0 && b>0))
		return Sign(a) * Min(temp, fabs(b));
	else
		return 0;
}
inline double Minmod(double a, double b, double c)
{
	if((a<0 && b<0 && c<0) || (a>0 && b>0 && c>0))
	{
	    double temp = fabs(a);
		temp = Min(temp, fabs(b));
		temp = Min(temp, fabs(c));

		return Sign(a) * temp;
	}
	else 
	{
		return 0;
	}
}
inline double Minmod(double a, double b, double c, double d)
{
	double temp = fabs(a);
	if((a<0 && b<0 && c<0 && d<0) || (a>0 && b>0 && c>0 && d>0))
	{
		temp = Min(temp, fabs(b));
		temp = Min(temp, fabs(c));
		temp = Min(temp, fabs(d));
		return Sign(a) * temp;
	}
	else 
		return 0;
}

// convert degree to arc and vice versa
inline double Deg2arc(double x)
{	return x * Pi / 180.0;	}

inline double Arc2deg(double x)
{	return x / Pi * 180.0;	}

// square
inline double Square(double x)
{
	return x*x;
}

//Gauss-Legendre Integrate (algebraic accuracy:2n-1)
template <typename T>
double gauss_Intg(double a, double b, int n, T (*func)(T))
{
	int i(0);
	vector<double> x(0);
	vector<double> w(0);
	double s(0);

	x.resize((n + 1) / 2);
	w.resize((n + 1) / 2);
	switch (n)
	{
		case 1:
			x[0] = 0; w[0] = 2;
			break;
		case 2:
			x[0] = 0.577350269189626; w[0] = 1.000000000000000;
			break;
		case 3:
			x[0] = 0.000000000000000; w[0] = 0.888888888888889;
			x[1] = 0.774596669241483; w[1] = 0.555555555555556;
			break;
		case 4:
			x[0] = 0.339981043584856; w[0] = 0.652145154862546;
			x[1] = 0.861136311594053; w[1] = 0.347854845137454;
			break;
		case 5:
			x[0] = 0.000000000000000; w[0] = 0.568888888888889;
			x[1] = 0.538469310105683; w[1] = 0.478628670499366;
			x[2] = 0.906179845938664; w[2] = 0.236926885056189;
			break;
		case 6:
			x[0] = 0.238619186083197; w[0] = 0.467913934572691;
			x[1] = 0.661209386466265; w[1] = 0.360761573048139;
			x[2] = 0.932469514203152; w[2] = 0.171324492379170;
			break;
		case 7:
			x[0] = 0.000000000000000; w[0] = 0.417959183673469;
			x[1] = 0.405845151377397; w[1] = 0.381830050505119;
			x[2] = 0.741531185599394; w[2] = 0.279705391489277;
			x[3] = 0.949107912342759; w[3] = 0.129484966168870;
			break;
		case 8:
			x[0] = 0.183434642495650; w[0] = 0.362683783378362;
			x[1] = 0.525532409916329; w[1] = 0.313706645877887;
			x[2] = 0.796666477413627; w[2] = 0.222381034453374;
			x[3] = 0.960289856497536; w[3] = 0.101228536290376;
			break;
		case 9:
			x[0] = 0.000000000000000; w[0] = 0.330239355001260;
			x[1] = 0.324253423403809; w[1] = 0.312347077040003;
			x[2] = 0.613371432700590; w[2] = 0.260610696402935;
			x[3] = 0.836031107326636; w[3] = 0.180648160694857;
			x[4] = 0.968160239507626; w[4] = 0.081274388361574;
			break;
		case 10:
			x[0] = 0.148874338981631; w[0] = 0.295524224714753;
			x[1] = 0.433395394129247; w[1] = 0.269266719309996;
			x[2] = 0.679409568299024; w[2] = 0.219086362515982;
			x[3] = 0.865063366688985; w[3] = 0.149451349150581;
			x[4] = 0.973906528517172; w[4] = 0.066671344308688;
			break;
		case 11:
			x[0] = 0.000000000000000; w[0] = 0.272925086777901;
			x[1] = 0.269543155952345; w[1] = 0.262804544510247;
			x[2] = 0.519096129110681; w[2] = 0.233193764591990;
			x[3] = 0.730152005574049; w[3] = 0.186290210927734;
			x[4] = 0.887062599768095; w[4] = 0.125580369464905;
			x[5] = 0.978228658146057; w[5] = 0.055668567116174;
			break;
		case 12:
			x[0] = 0.125333408511469; w[0] = 0.249147045813403;
			x[1] = 0.367831498918180; w[1] = 0.233492536538355;
			x[2] = 0.587317954286617; w[2] = 0.203167426723066;
			x[3] = 0.769902674194305; w[3] = 0.160078328543346;
			x[4] = 0.904117256370475; w[4] = 0.106939325995318;
			x[5] = 0.981560634246719; w[5] = 0.047175336386512;
			break;
		case 13:
			x[0] = 0.000000000000000; w[0] = 0.232551553230874;
			x[1] = 0.230458315955135; w[1] = 0.226283180262897;
			x[2] = 0.448492751036447; w[2] = 0.207816047536889;
			x[3] = 0.642349339440340; w[3] = 0.178145980761946;
			x[4] = 0.801578090733310; w[4] = 0.138873510219787;
			x[5] = 0.917598399222978; w[5] = 0.092121499837728;
			x[6] = 0.984183054718588; w[6] = 0.040484004765316;
			break;
		case 14:
			x[0] = 0.108054948707344; w[0] = 0.215263853463158;
			x[1] = 0.319112368927890; w[1] = 0.205198463721290;
			x[2] = 0.515248636358154; w[2] = 0.185538397477938;
			x[3] = 0.687292904811685; w[3] = 0.157203167158194;
			x[4] = 0.827201315069765; w[4] = 0.121518570687903;
			x[5] = 0.928434883663574; w[5] = 0.080158087159760;
			x[6] = 0.986283808696812; w[6] = 0.035119460331752;
			break;
		case 15:
			x[0] = 0.000000000000000; w[0] = 0.202578241925561;
			x[1] = 0.201194093997435; w[1] = 0.198431485327111;
			x[2] = 0.394151347077563; w[2] = 0.186161000015562;
			x[3] = 0.570972172608539; w[3] = 0.166269205816994;
			x[4] = 0.724417731360170; w[4] = 0.139570677926154;
			x[5] = 0.848206583410427; w[5] = 0.107159220467172;
			x[6] = 0.937273392400706; w[6] = 0.070366047488108;
			x[7] = 0.987992518020485; w[7] = 0.030753241996117;
			break;
		case 16:
			x[0] = 0.095012509837637; w[0] = 0.189450610455069;
			x[1] = 0.281603550779259; w[1] = 0.182603415044924;
			x[2] = 0.458016777657227; w[2] = 0.169156519395003;
			x[3] = 0.617876244402644; w[3] = 0.149595988816577;
			x[4] = 0.755404408355003; w[4] = 0.124628971255534;
			x[5] = 0.865631202387832; w[5] = 0.095158511682493;
			x[6] = 0.944575023073233; w[6] = 0.062253523938648;
			x[7] = 0.989400934991650; w[7] = 0.027152459411754;
			break;
		}
		double xr(0), xm(0), dx(0);
		xm = 0.5 * (b + a);
		xr = 0.5 * (b - a);
		s = 0;

		switch (n % 2)
		{
		case 0:
			for (i = 0; i != (n + 1) / 2; i++)
			{
				dx = xr * x[i];
				s += w[i] * ((*func)(xm + dx) + (*func)(xm - dx));
			}
			s *= xr;
			break;
		case 1:
			for (i = 1; i != (n + 1) / 2; i++)
			{
				dx = xr * x[i];
				s += w[i] * ((*func)(xm + dx) + (*func)(xm - dx));
			}
			s += w[0] * (*func)(xm);
			s *= xr;
			break;
		}

		return s;
}
//Gauss-Lobatto Integrate (algebraic accuracy:2n-3)
template <typename T>
double guass_Lobatto(double a, double b, int n, T (*func)(T))
{
	assert(n >= 3 && n <= 6);
	int i(0);

	vector<double> x(n,0);
	vector<double> w(n,0);
	switch(n)
	{
	case 3:
		x[0] = -1.0;         x[1] = 0.0; 
		x[2] = 1.0;

		w[0] = 0.333333333;  w[1] = 1.333333333; 
		w[2] = 0.333333333;
		break;
	case 4:
		x[0] = -1.0;         x[1] = -0.447213595;
		x[2] = 0.447213595;  x[3] = 1.0;

		w[0] = 0.166666667;  w[1] = 0.833333333;
		w[2] = 0.833333333;  w[3] = 0.166666667;
		break;
	case 5:
		x[0] = -1.0;         x[1] = -0.654653671;
		x[2] = 0.0;          x[3] = 0.654653671;   
		x[4] = 1.0;

		w[0] = 0.1;          w[1] = 0.544444444;
		w[2] = 0.711111111;  w[3] = 0.544444444;
		w[4] = 0.1;
		break;
	case 6:
		x[0] = -1.0;         x[1] = -0.765055324;
		x[2] = -0.285231516; x[3] = 0.285231516;
		x[4] = 0.765055324;  x[5] = 1.0;

		w[0] = 0.066666667;  w[1] = 0.378474956;
		w[2] = 0.554858377;  w[3] = 0.554858377;
		w[4] = 0.378474956;  w[5] = 0.066666667;
		break;
	}
	double xr(0), xm(0), dx(0);
	xm = 0.5 * (b + a);
	xr = 0.5 * (b - a);
	double s(0);
	for(i = 0; i < n; ++i)
	{
		s = s + w[i] * (*func)(xm + xr * x[i]);
	}
	s = s * xr;

	return s;
}
#endif 
